### The Purpose of Planning:
#### A good planning process supports this by:
- **Reducing risk:**
  - Planning increases the likelihood of project success by providing insights into the project’s risks. Some projects are so risky that we may choose not to start once we’ve learned about the risks. Other projects may contain features whose risks can be contained by early attention.
  - The discussions that occur while estimating raise questions that expose potential dark corners of a project. For example, suppose you are asked to estimate how long it will take to integrate the new project with an existing mainframe legacy system that you know nothing about. This will expose the integration features as a potential risk. The project team can opt to eliminate the risk right then by spending time learning about the legacy system. Or the risk can be noted and the estimate for the work either made larger or expressed as a range to account for the greater uncertainty and risk
- **Reducing uncertainty:**
  - Throughout a project, the team is generating new capabilities in the product. They are also generating new knowledge—about the product, the technologies in use, and themselves as a team. It is critical that this new knowledge be acknowledged and factored into an iterative planning process that is designed to help a team refine their vision of the product.
  - A project that delivers all features on the initial plan is not necessarily a success. The product’s users and customer would probably not be satisfied if wonderful new feature ideas had been rejected in favor of mediocre ones simply because the mediocre features were in the initial plan.
- **Supporting better decision making:**
  - Estimates and plans help us make decisions. How does an organization decide if a particular project is worth doing if it does not have estimates of the value and the cost of the project? Beyond decisions about whether or not to start a project, estimates help us make sure we are working on the most valuable projects possible.
  - Suppose an organization is considering two projects, one is estimated to make $1 million and the second is estimated to make $2 million. First, the organization needs schedule and cost estimates in order to determine if these projects are worth pursuing. Will the projects take so long that they miss a market window? Will the projects cost more than they’ll make? Second, the organization needs estimates and a plan so that they can decide which to pursue. The company may be able to pursue one project, both projects, or neither if the costs are too high.
- **Establishing trust:**
  - Frequent reliable delivery of promised features builds trust between the developers of a product and the customers of that product. Reliable estimates enable reliable delivery. A customer needs estimates in order to make important prioritization and tradeoff decisions.
  - Reliable estimates benefit developers by allowing them to work at a sustainable pace. This leads to higher quality code and fewer bugs. These, in turn, lead back to more reliable estimates because less time is spent on highly unpredictable work such as bug fixing
- **Conveying information:**
  - A plan conveys expectations and describes one possibility of what may come to pass over the course of a project. A plan does not guarantee an exact set of features on an exact date at a specified cost. A plan does, however, communicate and establish a set of baseline expectations. 
  - Suppose you ask me when a project will be done. I tell you seven months but provide no explanation of how I arrived at that duration. You should be skeptical of my estimate. Without additional information you have no way of determining whether I’ve thought about the question sufficiently or whether my estimate is realistic.

### Q. What Makes Planning Agile?
- Agile planning balances the effort and investment in planning with the knowledge that we will revise the plan through the course of the project. An agile plan is one that we are not only willing but anxious to change. We don’t want to change the plan just for the sake of changing, but we want to change because change means we’ve learned something or that we’ve avoided a mistake. 
- We may have learned that users want more of this feature or that they want less of that feature or that usability is more important than we’d believed or that programming in this new language takes longer than we’d expected. The financial impact of each of these changes can be assessed and, if worthy, can alter the plan and schedule.
- As we discover these things, they impact our plans. This means we need plans that are easily changed. This is why the planning becomes more important than the plan. The knowledge and insight we gain from planning persists long after one plan is torn up and a revised one put in its place. So, an agile plan is one that is easy to change.
- Just because we’re changing the plan does not mean we change the dates. We may or may not do that. But if we learn we were wrong about some aspect of the target product and need to do something about it, then the plan needs to change. There are many ways we can change the plan without changing the date. We can drop a feature, we can reduce the scope of a feature, we can possibly add people to the project, and so on.

### Q. Why Planning Fails?
- **Planning Is By Activity Rather Than Feature:**
	- A critical problem with traditional approaches to planning is that they focus on the completion of activities rather than on the delivery of features. A traditionally managed project’s Gantt chart or work breakdown structure identifies the activities that will be performed. This becomes how we measure the progress of the team. A first problem with activity-based planning is that customers get no value from the completion of activities. Features are the unit of customer value. Planning should, therefore, be at the level of features, not activities.
	- A second problem occurs after a traditional schedule has been created and is being reviewed. When we review a schedule showing activities we do so looking for forgotten activities rather than for missing features.
	- Some of the reasons why activity-based planning leads to schedule overruns include:
		- Activities don’t finish early
		- Lateness is passed down the schedule
		- Activities are not independent
- **Multitasking Causes Further Delays:**
  - A second reason why traditional approaches to planning often fail is multitasking, which is defined as simultaneously working on multiple tasks. Multitasking exacts a horrible toll on productivity.
- **Features Are Not Developed By Priority:**
  - A third reason why traditional planning fails to consistently lead to high-value products is because the work described by the plan is not prioritized by the value to the users and customer. Many traditional plans are created with the assumption that all identified activities will be completed. This means that work is typically prioritized and sequenced for the convenience of the development team.
- **We Ignore Uncertainty:**
  - A fourth shortcoming with traditional approaches to planning is the failure to acknowledge uncertainty. We ignore uncertainty about the product and assume that the initial requirements analysis led to a complete and perfect specification of the product. We assume that users will not change their minds, refine their opinions, or come up with new needs during the period covered by the plan.
- **Estimates Become Commitments:**
  - Embedded within each and every estimate is a probability that the work will be completed in the estimated time. Suppose your team has been asked to develop a new high-end word processor. The probability of finishing this by the end of the week is 0%. The probability of finishing it in ten years is 100%. If I ask you for an estimate and you tell me the end of the week, that estimate comes with a probability of 0%. If the estimate you give me is ten years, that estimate comes with a probability of 100%. Each estimate between the end of the week and ten years from now comes with its own probability between 0% and 100% (Armour 2002)

### An Agile Approach To Projects:
With an understanding of the four primary agile value statements, we can turn our attention to what an agile team looks like in practice. Taken collectively, the four value statements lead to software development processes that are highly iterative and incremental and that deliver coded and tested software at the end of each iteration. The following sections cover some of the main ways in which agile teams work. Including that they:
- Work as one team
- Work in short iterations
- Deliver something each iteration
- Focus on business priorities
- Inspect and adapt

### An Agile Approach To Projects:
With an understanding of the four primary agile value statements, we can turn our attention to what an agile team looks like in practice. Taken collectively, the four value statements lead to software development processes that are highly iterative and incremental and that deliver coded and tested software at the end of each iteration. The following sections cover some of the main ways in which agile teams work. Including that they:
- Work as one team:
  - Critical to the success of a project is that all project participants view themselves as one team aimed at a common goal. There is no room for a “throw it over the wall” mentality on an agile project.
- Work in short iterations:
  - On an agile project there is no grand delineation of phases—no upfront requirements phase followed by analysis followed by architectural design and so on. Depending upon the actual agile process you select or define, you may put a very short design, modeling, or other phase at the front end of the project. But, once the project has begun in earnest, all work (requirements, design, coding, testing, and so on) happens concurrently within each iteration.
- Deliver something each iteration:
  - More crucial than the specific iteration length chosen by a team is that during the iteration they transfrom one or more imprecise requirements statements into coded, tested, and potentially shippable software. 
- Focus on business priorities:
  - Agile teams demonstrate a commitment to business priorities in two ways. First, they deliver features in the order specified by the product owner, who is expected to prioritize and combine features into a release that optimizes the return on the organization’s investment in the project. 
  - Second, agile teams focus on completing and delivering user-valued features rather than on completing isolated tasks (that eventually combine into a uservalued feature). One of the best ways to do this is to work with user stories, which are a lightweight technique for expressing software requirements.
- Inspect and adapt
  - The plan created at the start of any project is not a guarantee of what will occur. In fact, it is only a point-in-time guess. Many things will conspire to invalidate the plan—project personnel may come or go, technologies will work better or worse than expected, users will change their minds, competitors may force us to respond differently or more rapidly, and so on. Agile teams view every such change as presenting both the opportunity and need to update the plan in order to better reflect the reality of the current situation.

### An Agile Approach to Planning:
- Agile teams use three levels of planning: release planning, iteration planning, and daily planning. 
- The release plan looks ahead for the duration of the release, typically three to six months. An iteration plan looks ahead only the duration of one iteration, typically one to four weeks. A daily plan is the result of team member commitments made to each other usually during a daily standup meeting.
- Understanding the product owner’s condiditions of satistaction is critical in both release and iteration planning. During release planning, the whole team identifies a way of meeting the conditions of satisfaction for the release, which
includes scope, schedule, and resources. 
- To achieve this, the product owner may need to relax one or more of her conditions of satisfaction. A similar process occurs during iteration planning when the conditions of satisfaction are the new features that will be implemented and the high level test cases that demonstrate the features were implemented correctly.

### Estimating Size with Story Points
- Story Points Are Relative:
  - Story points are a unit of measure for expressing the overall size of a user story, feature, or other piece of work. When we estimate with story points we assign a point value to each item. The raw value we assign is unimportant. What matters are the relative values. A story that is assigned a two should be twice as much as a story that is assigned a one. It should also be two-thirds of a story that is estimated as three story points.
  - There are two common ways to get started. The first appoach is to select a story that you expect to be one of the smallest stories you’ll work with and say that story is estimated at 1 story point. 
  - The second approach is instead to select a story that seems somewhat medium-sized and give it a number somewhere in the middle of the range you expect to use. 
- Velocity:
  - Velocity is a measure of a team’s rate of progress. It is calculated by summing the number of story points assigned to each user story that the team completed during the iteration. If the team completed three stories each estimated at five story points then their velocity would be fifteen. If the team completed two five-point stories their velocity would be ten.
  - If a team completed ten story points of work last iteration, our best guess is that they will complete ten story points this iteration. Since story points are estimates of relative size, this will be true whether they work on two five-point stories or five two-point stories

### Techniques for Estimating
- Estimates Are Shared:
  - First, on an agile project we tend not to know specifically who will perform a given task. Yes, we may all suspect that the team’s database guru will be the one to do the complex stored procedure task that has been identified. However, there’s no guarantee that this will be the case. She may be busy when the time comes and someone else will work on it. So, since anyone may work on anything, it is important that everyone have input into the estimate.
  - Second, even though we may expect the database guru to do the work, others may have something to say about her estimate. Suppose, for example, that the team’s database guru, Kristy, estimates a particular user story as three ideal days. Someone else on the project may not know enough to program the feature himself but he may know enough to say, “Kristy, you’re nuts; the last time you worked on a feature like that it took a lot longer. I think you’re forgetting how hard it was last time.” At that point Kristy may offer a good explanation of why it’s different this time. However, more often than not in my experience, she will acknowledge that she was indeed underestimating the feature.
- Estimation Scale:
  - Two estimation scales I’ve had good success with are:
    - The first is the Fibonacci sequence. [1, 2, 3, 5, and 8]
    - The second sequence is spaced such that each number is twice the number that precedes it.[1, 2, 4, and 8]
  - Each of these numbers should be thought of as a bucket into which items of the appropriate size are poured. Rather than thinking of work as water being poured into the buckets, think of the work as sand. If you are estimating using 1, 2, 3, 5, and 8 and have a story that you think is just the slightest bit bigger than the other five-point stories you’ve estimated, it would be OK to put it into the five-point bucket. A story you think is a 7, however, clearly would not fit in the five-point bucket.
- User Stories, Epics, And Themes:
  - A large user story is sometimes called an epic.
  - A set of related user stories may be combined together and treated as a single entity for either estimating or release planning. Such a set of user stories is referred to as a theme. An epic, by its very size alone, is often a theme on its own. 
  - By aggregating some stories into themes and writing some stories as epics, a team is able to reduce the effort they’ll spend on estimating. However, it’s important that they realize that estimates of themes and epics will be more uncertain than estimates of the more specific, smaller user stories.
- Deriving An Estimate:
  - The three most common techniques for estimating are:
    - Expert opinion:
      - If you want to know how long something is likely to take, ask an expert. At least, that’s one approach. This approach is less useful on agile projects than on traditional projects. On an agile project, estimates are assigned to user stories or other user-valued functionality. Developing this functionality is likely to require a variety of skills normally performed by more than one person. This makes it difficult to find suitable experts who can assess the effort across all disciplines. 
    - Analogy:
      - An alternative to expert opinion comes in the form of estimating by analogy, which is what we’re doing when we say “this story is a little bigger than that story.” When estimating by analogy, the estimator compares the story being estimated to one or more other stories. If the story is twice the size, it is given an estimate twice as large.
      - When estimating this way you do not compare all stories against a single baseline or universal reference. Instead, you want to estimate each new story against an assortment of those that have already been estimated. This is referred to as triangulation. 
      - To triangulate, compare the story being estimated against a couple of other stories. To decide if a story should be estimated at five story points, see if it seems a little bigger than a story you estimated at three and a little smaller than a story you estimated at eight.
    - Disaggregation:
      - Disaggregation refers to splitting a story or feature into smaller, easier-to-estimate pieces. If most of the user stories to be included in a project are in the range of 2-5 days to develop, it will be very difficult to estimate a single story that may be 100 days. Not only are large things notoriously more difficult to estimate, but in this case there will be very few similarly sized stories to compare to.
      - The solution to this, of course, is to break the large story or feature into multiple smaller items and estimate those. However, you need to be careful not to go too far with this approach. 
- Planning Poker:
  - Planning poker, also known as “scrum poker” and “pointing poker”, is a gamified technique that development teams use to guess the effort of project management tasks.
  - These estimations are based on the entire group’s input and consensus, making them more engaging and accurate than other methods. 
  - Planning poker combines expert opinion, analogy, and disaggregation into an enjoyable approach to estimating that results in quick but reliable estimates.
    - Step 1: Hand out the cards to participants:
      - Distribute an identical deck of cards to everybody. Each one has a number that the team has agreed to use as their estimate. Each player should have a deck consisting of different numbers. Cohn recommended a sequence of 0, 1, 2, 3, 5, 8, 13, 20, 40, and 100. 
    - Step 2: Read the story out loud
      - The moderator (either the product owner or product manager) narrates the story to the group. If participants have any questions, the moderator answers them.
    - Step 3: Discuss the story:
      - Once the group finishes listening to the story, everyone shares their views on it. Some of these discussion points will likely include: How should we handle the work?
    - Step 4: Select and share
      - After the discussion, each person will privately select a card from the deck. Usually, it’s used to show an estimate of story points (but can also be used to represent the number of ideal days). Once everyone selects a card, they show them at the same time.
    - Step 5: Reach a consensus
      - When team members show the same card, that number turns into a consensus. Now, the group can move forward and work on the next story.
  - The benefits:
    - Estimating tasks relative to each other.
    - Lending an equal voice to everyone on the team. 
    - Identifying gaps in requirement and implementation.









